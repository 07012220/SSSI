\documentclass[11pt]{article}
\usepackage[centertags]{amsmath}
\usepackage{hyperref}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{amsthm}
\usepackage{newlfont}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{abstract}
\usepackage{tikz}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{algorithm,algorithmic}
\usepackage[]{mcode}

\bibliographystyle{amsplain}
\renewcommand{\textfraction}{0.15}
\renewcommand{\topfraction}{0.85}
\renewcommand{\bottomfraction}{0.65}
\renewcommand{\floatpagefraction}{0.60}
%\newcommand{\topfigrule}{%
%  \vspace*{5pt}\hrule\vspace{-5.4pt}}
%\newcommand{\botfigrule}{\vspace*{-5.4pt}\hrule\vspace{5pt}}


\newlength{\defbaselineskip}
\setlength{\defbaselineskip}{\baselineskip}
\newcommand{\setlinespacing}[1]%
           {\setlength{\baselineskip}{#1 \defbaselineskip}}
\newcommand{\doublespacing}{\setlength{\baselineskip}%
                           {2.0 \defbaselineskip}}
\newcommand{\singlespacing}{\setlength{\baselineskip}{\defbaselineskip}}
% MATH -------------------------------------------------------------------
\newcommand{\A}{{\cal A}}
\newcommand{\h}{{\cal H}}
\newcommand{\s}{{\cal S}}
\newcommand{\W}{{\cal W}}
\newcommand{\D}{{\cal D}}
\newcommand{\NN}{\mathbb N}
\newcommand{\BH}{\mathbf B(\cal H)}
\newcommand{\KH}{\cal  K(\cal H)}
\newcommand{\Int}{\mathbb Z}
\newcommand{\Complex}{\mathbb C}
\newcommand{\Field}{\mathbb F}
\newcommand{\RPlus}{[0,\infty)}
\newcommand{\rip}{\operatorname{RIP}}
\newcommand{\pj}{\text{Proj}}
\newcommand{\csp}{\overline{\operatorname{span}}}
\newcommand{\spn}{\operatorname{span}}
%
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}
\newcommand{\essnorm}[1]{\norm{#1}_{\text{\rm\normalshape ess}}}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\seq}[1]{\left<#1\right>}
\newcommand{\eps}{\varepsilon}
\newcommand{\To}{\longrightarrow}
\newcommand{\RE}{\operatorname{Re}}
\newcommand{\IM}{\operatorname{Im}}
\newcommand{\supp}{\text{supp}}
\newcommand{\Poly}{{\cal{P}}(E)}
\newcommand{\EssD}{{\cal{D}}}
\newcommand{\argmin}{\operatornamewithlimits{argmin}}
\newcommand{\argmax}{\operatornamewithlimits{argmax}}
\newcommand{\Fc}{\mathcal{F}}
\newcommand{\Ac}{\mathcal{A}}
\newcommand{\Ic}{\mathcal{I}}
\newcommand{\Nc}{\mathcal{N}}
\newcommand{\Ex}{\mathbb{E}}
\newcommand{\real}{\mathbb{R}}
%\newcommand{\Pr}{\textsc{P}}
\newcommand{\cL}{\mathcal{L}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\Xf}{\mathfrak{X}}
\newcommand{\bx}{\boldsymbol{x}}
\newcommand{\by}{\boldsymbol{y}}
\newcommand{\bw}{\boldsymbol{w}}
\newcommand{\bmu}{\boldsymbol{\mu}}
\newcommand{\bthe}{\boldsymbol{\theta}}
\newcommand{\bA}{\boldsymbol{A}}
\newcommand{\ba}{\boldsymbol{a}}
\newcommand{\bb}{\boldsymbol{b}}
\newcommand{\bd}{\boldsymbol{d}}
\newcommand{\bff}{\boldsymbol{f}}
\newcommand{\bF}{\boldsymbol{F}}
\newcommand{\bp}{\boldsymbol{p}}
\newcommand{\bG}{\boldsymbol{G}}
\newcommand{\bg}{\boldsymbol{g}}
\newcommand{\bh}{\boldsymbol{h}}
\newcommand{\bH}{\boldsymbol{H}}
\newcommand{\bk}{\boldsymbol{k}}
\newcommand{\bL}{\boldsymbol{L}}
\newcommand{\bs}{\boldsymbol{s}}
\newcommand{\bm}{\boldsymbol{m}}
\newcommand{\bn}{\boldsymbol{n}}
\newcommand{\bP}{\boldsymbol{P}}
\newcommand{\bR}{\boldsymbol{R}}
\newcommand{\bI}{\boldsymbol{I}}
\newcommand{\bJ}{\boldsymbol{J}}
\newcommand{\bQ}{\boldsymbol{Q}}
\newcommand{\bU}{\boldsymbol{U}}
\newcommand{\bV}{\boldsymbol{V}}
\newcommand{\bLam}{\boldsymbol{\Lambda}}
\newcommand{\bzero}{\boldsymbol{0}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\mymatrix}[1]{\begin{bmatrix} #1\end{bmatrix}}
\newcommand{\comment}[1]{}
\newcommand{\tr}{{\text{tr}}}
\newcommand{\hx}{\hat{\mathbf{x}}}
\newcommand{\hy}{\hat{\mathbf{y}}}
\newcommand{\hz}{\hat{\mathbf{z}}}
\newcommand{\sff}{\mathsf{f}}





% THEOREMS ---------------------------------------------------------------
\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}{Lemma}[section]
\newtheorem{prop}[thm]{Proposition}
%
\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{eg}{Example}[section]
%
\theoremstyle{remark}
\newtheorem{rem}{Remark}[section]
%
\numberwithin{equation}{section}
\renewcommand{\theequation}{\thesection.\arabic{equation}}
\newcommand{\ds}{\displaystyle}
\newtheorem{assum}{Assumption}
\newtheorem{them}{Theorem}[section]
\newtheorem{coro}{Corollary}[section]
\setcounter{section}{-1}

\begin{document}
\title{User Guide of Seismic Simulation, Survey, and Imaging (SSSI)}
\author{Entao Liu \thanks{Center for Energy \& Geo Processing (CeGP), School of ECE, Georgia Tech, e-mail: liuentao@gmail.com}
and Lingchen Zhu \thanks{Center for Signal and Information Processing (CSIP), School of ECE, Georgia Tech 
e-mail: lczhu@gatech.edu}} \maketitle
\tableofcontents
\newpage
\section{Requirements and License}

The SSSI is a Matlab based package. Besides Matlab (2012a or later version recommend), you also need a C++ compiler to generate the mex function. 
SSSI is free software package: you can redistribute it and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation, version 2.0 of the License only. This program is distributed in the hope that 
it will be useful, but WITHOUT ANY WARRANTY. If you find any glitches within the package, please contact the authors. 
We appreciate you contributions. 


\section{Introduction}
The SSSI is designed to provide a package for numerical exploration geophysics. The purpose of package is more about providing a package for the interested 
users to learn some popular algorithms and numerical schemes in exploration geophysics than the high performance of the computation as commercial software. 
Thus, we choose the Matlab as the coding platform for its readability of the codes, ease of data visualization, etc. It is well known that nested for-loops on Matlab 
is comparatively slow. In order to have a better efficiency, we use C to generate mex files for some frequently invoked functions.
Currently, the major functions has been of the package are the following:
\begin{itemize}
\item Acoustic wave simulation for 2-D/3-D
\item Elastic wave simulation for 2-D
\item Kirchhoff's migration
\item Reverse Time Migration (RTM)
\item Full Waveform Inversion (FWI)
\end{itemize}

We do not intend to provide a comprehensive review of numerical simulation of wave equation and seismic imaging in this user guide. 
It is hopefully a guide for you to quickly learn how to use SSSI and what you can do with it. We will only show and explain necessary 
equations to keep the contents concise. Interested users are suggested to read the references therein for details.  


\section{Numerical Simulation of Acoustic Wave}
\subsection{Acoustics wave equation}
The seismic method is one of the basic tools in exploration geophysics. In seismic survey, man-made vibration sources (e.g. dynamite, viborseis trucks, and air gun) are fired off. Then the wave propagates through the subsurface media. The wave filed which contains direct wave, reflection, and refraction, will be recorded by array of receivers (e.g. geophones and hydrophones). In order to simulate this process with computers, it is crucial to solve the wave propagation numerically in the complex media accurately and efficiently. The real earth is an elastic media, such that the seismic waves contain both P-wave and S-wave components. For simplicity, we some times only consider the P-wave field, which is mathematically described by an acoustic wave equation. It is verified by borehole data that the media density variations are not the main source of reflected waves \cite{Hoo1981}. Therefore, it is reasonable to assume a constant density of the media. Then the acoustic wave equation is of the the form  
\begin{equation}\label{aw}
\frac{1}{c^2(\bx)}\frac{\partial^2 p(\bx,t)}{\partial t^2}-\Delta p(\bx,t)=f(\bx,t),
\end{equation}
where $p(\bx)$ is the filed of pressure variation and $\bx=(z,x)$ or $\bx=(z,x,y)$ is the coordinates in the Cartesian coordinate system for the 2-D and 3-D case, respectively. Following the convention in geophysics, the $z$ direction is pointing downwards. The $c(\bx)$ is the velocity of P-wave at location $\bx$. The $f_s(\bx,t)$ is the source term. Moreover, $\Delta$ in (\ref{aw}) is the Laplace operator defined as 
\begin{equation}
\Delta: =\left\{
\begin{aligned}
\frac{\partial^2}{\partial x^2}+\frac{\partial^2}{\partial z^2}~~~~~~~ & ~~~~\text{for 2-D }\\
\frac{\partial^2}{\partial x^2}+\frac{\partial^2}{\partial y^2}+\frac{\partial^2}{\partial z^2} &~~~~ \text{for 3-D}
\end{aligned}
\right.  
\end{equation}

The Ricker wavelet is a widely used for seismic source term whose amplitude $A(t)$ with the peak frequency $\sff$ at time $t$ is computed 
as:
\begin{equation}
A(t)=(1-2\pi^2 \sff^2 t^2)e^{-\pi^2 \sff^2 t^2}.
\end{equation}
The \path{src/ricker.m} provides a Ricker wavelet generator which requires the peak frequency $\sff$, number of time samples $n$, 
sampling time $dt$, and peak location $t_0$ as inputs. The Figure \ref{fig:ricker} illustrates the waveform of a Ricker wavelet with peak frequency equals 20 Hz. In SSSI you can choose from several different wavelets for the source term (Ricker wavelet, Fuchs-Mueller wavelet, sine cube wavelet, etc), which can be generated by \path{src/waveletGenerator.m}.

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{Fig/ricker}
\caption{Ricker wavelet with peak frequency $\sff=20$Hz}
\label{fig:ricker}
\end{figure}

\subsection{Finite Difference Method on Standard Grid}
There are two popular methods of solving the wave equation numerically. One is the Finite Difference Method (FDM), the other is the Finite Elements Method (FEM) method. Each method has its pros and cons. Concretely, the FDM which is adopted by the SSSI is simple to implement. For most of the simulations, it has sufficient accuracy. The FEM usually provides more accurate results, which is based on adaptive meshing (multiscale) of the simulated region. However, its implementation is less straightforward, especially when adding boundary conditions.   

In order to solve the wave equation with FDM, functions are represented by their values at certain discrete grid points and and derivatives are approximated through difference in these values. For instance, in a 2-D region we use the equi-distributed grid points $(z_i)_{0\le i \le I-1 }$, $(x_j)_{0\le j \le J-1}$, and $(t_n)_{0\le n \le N-1}$ given by $z_i = i\Delta z$, $x_j = j\Delta x$ and $t_n=n\Delta t$. Instead of solving the wave equation in a continuous domain (both in space and time) analytically, the FDM looks for a numerical solution on these grid points.  

A crucial step of FDM for wave equations is to find good approximations of the derivatives in (\ref{aw}) with function values on the grid points. Let us begin with the definition of the derivative, 
 \begin{equation}
  \begin{aligned}
  \frac{\partial p(z, x, t)}{\partial z} &= \lim\limits_{\Delta z \rightarrow 0} \frac{p(z+\Delta z, x, t) - p(z, x, t)}{\Delta z}\\
  &\approx \frac{p(z+\Delta z, x, t) - p(z, x, t)}{\Delta z}.
  \end{aligned}
  \end{equation}
 Assuming the finite grid size $\Delta z$ is small enough, $(p(z+\Delta z, x, t) - p(z, x, t))/\Delta z$ is an accurate estimation of the derivative.
  Apply this approximation twice. We can derive an estimation of the 2nd derivative in (\ref{aw})
  \begin{equation}
  \begin{aligned}
  &\frac{\partial^2 p(z, x, t)}{\partial z^2} = \frac{\partial}{\partial z}\frac{\partial p(z, x, t)}{\partial z} \approx \frac{\frac{\partial p(z, x, t)}{\partial z} - \frac{\partial p(z-\Delta z, x, t)}{\partial z}}{\Delta z}\\
  &\approx \frac{p(z+\Delta z, x, t) - 2p(z, x, t) + p(z-\Delta z, x, t)}{\Delta z^2}.
  \end{aligned}
  \end{equation}
  
For simplicity of the notations, we denote $p_{i,j}^{(n)}:=  p(i\Delta z, j\Delta x, n\Delta t)$, $f_{i,j}^{(n)} := f(i\Delta z, j\Delta x, n\Delta t)$, $v_{i,j} := v(i\Delta z, j\Delta x)$.
 Therefore, a finite difference expression of 2-D acoustic wave equation can be written as 
  \begin{equation}
    \begin{aligned}
    &\frac{1}{v_{i,j}^2}\frac{p_{i,j}^{(n+1)} - 2p_{i,j}^{(n)} + p_{i,j}^{(n-1)}}{\Delta t^2} - f_{i,j}^{(n)} \\
    &= \frac{p_{i+1,j}^{(n)} - 2p_{i,j}^{(n)} + p_{i-1,j}^{(n)}}{\Delta z^2} + \frac{p_{i,j+1}^{(n)} - 2p_{i,j}^{(n)} + p_{i,j-1}^{(n)}}{\Delta x^2}.
    \end{aligned}
  \end{equation}
Simple algebraic manipulations lead to a recursive expression of the wave equation,
  \begin{equation}\label{StaGrid}
    \begin{aligned}
    &p_{i,j}^{(n+1)} = \frac{v_{i,j}^2\Delta t^2}{\Delta z^2}\left(p_{i+1,j}^{(n)} - 2p_{i,j}^{(n)} + p_{i-1,j}^{(n)}\right)\\
    &+ \frac{v_{i,j}^2\Delta t^2}{\Delta x^2}\left(p_{i,j+1}^{(n)} - 2p_{i,j}^{(n)} + p_{i,j-1}^{(n)}\right)\\
    &+ 2p_{i,j}^{(n)}-p_{i,j}^{(n-1)} + v_{i,j}^2\Delta t^2 f_{i,j}^{(n)}.
    \end{aligned}
  \end{equation}
  In (\ref{StaGrid}), all values of $p$ are computed on integer grid points as we illustrated in Figure \ref{fig:stanG}. The FDM on standard grid is an easy-to-understand numerical scheme, which serves as an excellent explanatory example. However, it is not adopted in SSSI because of its drawbacks in accuracy.  
  
\begin{figure}
\centering
\begin{subfigure}[b]{.4\textwidth}
\includegraphics[width=5cm]{Fig/stanGrid}
\caption{Standard Grid.}
\label{fig:stanG}
\end{subfigure}
~~~~~
\begin{subfigure}[b]{0.4\textwidth}
\includegraphics[width=5cm]{Fig/StagGrid}
\caption{Staggerd Grid.}
\label{fig:stagG}
\end{subfigure}
\caption{Discretization grids.}
\end{figure}

\subsection{Finite Difference Method on Staggered Grid}
With a sophisticated design, we can actually obtain higher order of approximation of the derivatives if we have access to the value of $p$ on the half grid points, as denoted by the green dots in Figure \ref{fig:stagG}. 

By Taylor expansion of a function $p(u)$ on the half grid points
  \begin{equation}\label{half1}
      p\left(u + \frac{2k+1}{2}\Delta u\right) = p(u) + \sum\limits_{n=1}^{\infty} \frac{1}{n!}\frac{\partial^n p(u)}{\partial u^n}\left(\frac{2k+1}{2}\Delta u\right)^n, 
      \end{equation}
      \begin{equation}\label{half2}
      p\left(u - \frac{2k+1}{2}\Delta u\right) = p(u) + \sum\limits_{n=1}^{\infty} \frac{(-1)^n}{n!}\frac{\partial^n p(u)}{\partial u^n}\left(\frac{2k+1}{2}\Delta u\right)^n,
  \end{equation}
where $u = z, x; \; k = 0, 1, 2, \dots $.
  Take the difference between (\ref{half1}) and (\ref{half2}) which cancels all the terms when $n$ is even.
So it implies for $k = 0, 1, 2, \dots$
\begin{equation}    \label{Fdiff}
    \begin{aligned}
   &  \frac{p\left(u + \frac{2k+1}{2}\Delta u\right) - p\left(u - \frac{2k+1}{2}\Delta u\right)}{(2k+1)\Delta u}\\
    &~~~~~~~~~  =  \frac{\partial p(u)}{\partial u} + \sum\limits_{n=1 }^{\infty} \frac{1}{(2n+1)!}\frac{\partial^{(2n+1)} p(u)}{\partial u^{(2n+1)}}\left(\frac{2k+1}{2}\Delta u\right)^{2n}.
    \end{aligned}
    \end{equation}
We can approximate $\frac{\partial p(u)}{\partial u}$ as a weighted sum of finite differences in (\ref{Fdiff})
  \begin{equation}\label{weight}
  \begin{aligned}
    &\frac{\partial p(u)}{\partial u} = \sum\limits_{k=0}^{N-1} a_k \frac{p\left(u + \frac{2k+1}{2}\Delta u\right) - p\left(u - \frac{2k+1}{2}\Delta u\right)}{(2k+1)\Delta u} \\
    &= \sum\limits_{k=0}^{N-1} a_k \left[ \frac{\partial p(u)}{\partial u} + \frac{\Delta u^2}{3! \cdot 2^2}(2k+1)^2\frac{\partial^3 p(u)}{\partial u^3} \right.\\&\left. + \frac{\Delta u^4}{5! \cdot 2^4}(2k+1)^4\frac{\partial^5 p(u)}{\partial u^5} + \cdots \right.\\&\left. + \frac{\Delta u^{2N-2}}{(2N-1)! \cdot 2^{2N-2}}(2k+1)^{2N-2}\frac{\partial^{2N-1} p(u)}{\partial u^{2N-1}} + o(\Delta u^{2N}) \right].
  \end{aligned}
  \end{equation}
If the weighted $\{ a_k\}_{k=0}^{N-1}$ are chosen carefully, we can eliminate all the term on the right hand side of (\ref{weight}) and make the coefficient of $\frac{\partial p(u)}{\partial u} =1$. These $N$ weights generate a approximation of the derivative of order $2N$. Additionally, the derivative $\frac{\partial p(u)}{\partial u}$ and function itself $p(u)$ live on different colors of dots, i.e. $\frac{\partial p(u)}{\partial u}$ on half gird points, and $p(u)$ on integer grid points.

Solving $\{a_k\}_{k=0}^{N-1}$ by the following linear equations
\begin{equation*}
\begin{bmatrix}
  1 & 1 & \cdots & 1 \\
  1^2 & 3^2 & \cdots & (2N-1)^2 \\
  1^4 & 3^4 & \cdots & (2N-1)^4 \\
  \vdots & \vdots & \ddots & \vdots \\
  1^{2N-2} & 3^{2N-2} & \cdots & (2N-1)^{2N-2} \\
\end{bmatrix}
\begin{bmatrix}
  a_0 \\ a_1 \\ a_2 \\ \vdots \\ a_{N-1}
\end{bmatrix}
=
\begin{bmatrix}
  1 \\ 0 \\ 0 \\ \vdots \\ 0
\end{bmatrix}
\end{equation*}
\begin{equation*}
  \begin{aligned}
  N = 1&: a_0 = 1\\
  N = 2&: a_0 = 9/8, a_1 = -1/24\\
  N = 3&: a_0 = 75/64, a_1 = -25/384, a_2 = 3/640\\
  &\vdots
  \end{aligned}
\end{equation*}

The source code which generates the appropriate weights can be found at \path{src/dCoef.m}. Moreover, the finite difference operator on staggered grid is fulfilled by \path{src/diffOperator.m} which can perform arbitrarily high order of approximation. The default value of \texttt{nDiffOrder = 3} generates 6-th order of approximation of the spatial derivatives.


\subsection{Absorbing Boundary Conditions (ABC)}
For the sake of efficiency and storage, we only simulate wave propagation in a truncated region which contains the seismic source and array of sensors. In a real seismic survey, the seismic wave generated by the source should have no reflection on the simulation boundaries to mimic the unbounded media. If we do not take care with particular techniques and run the recursive formula, say (\ref{StaGrid}), the numerical simulation will generate strong reflections on the boundaries which do not exist in the real earth. In order to attenuate the reflections, a common method is to impose the absorbing boundary conditions (ABC) \cite{EngMaj1977, ClaEng1977}. Figure \ref{fig:ABC} illustrates the 2-D scenario, when we pad the original velocity model's left, right, bottom boundaries with absorbing boundaries of certain width (fulfilled by \path{src/extBoundary.m}). ABC will attenuated the wave amplitude in those absorbing boundaries and keep it unaltered outside of the absorbing boundaries. Throughout the SSSI, except specified explicitly, we consider the top of the simulated region to be the surface of the earth, which is a free surface. Therefore, no absorbing boundary added to it.

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{Fig/abc.png}
\caption{Absorbing boundaries of the 2-D simulation region}
\label{fig:ABC}
\end{figure}

Numerically, a simple but efficient method for the ABC is called sponge ABC \cite{CerKosAO1985}. Suggested by its name, the reflections are exponentially attenuated in the extended artificial boundary area by multiplying a factor $d(u) < 1$.
\begin{equation}
  d(u) = e^{-\alpha^2\text{dist}(u)^2}, \mbox{  where  } u=x, z
\end{equation}
where $\text{dist}(u)$ is the distance from $u$ to the original boundary in the $u$ direction. 

The source code of which implements the acoustic wave propagation with sponge ABC 
is \path{src/fwdTimeSpongeFor2dAw.m}. Through out all names of the source files in SSSI,  we follow this rule: \path{fwd} means forward (\path{rvs} means reverse); \path{Time} means the equation is solved in the time domain (\path{freq} means in frequency domain); \path{For2d} means 2-D (\path{For3d} means 3-D); and \path{Aw} is short
 for acoustic wave (\path{Ew} is for elastic wave).  Although the waves are attenuated by ABC, however the reflection can not be completely eliminated. This is the reason in SSSI we utilize the following method called Perfectly Matched Layer as well. 



\subsubsection{Perfectly Matched Layer (PML)}
 Perfectly Matched Layer (PML) method which was originally formulated for use with electromagnetic equations which outperforms other existing methods. The PML is proven to be efficient for wave equations (both acoustic and elastic) as well \cite{KomMar2007}. It has a zero reflection coefficient for all angles of incidence and all frequencies before discretization. Moreover, a PML interface between a physical medium and the extended artificial boundary completely absorbs incident waves from the physical medium regardless of its incidence angle and frequency.
By defining a damping profile $d(u)$ ($u=z, x, y$) function (see \path{src/dampPml.m}) such that $d(u) = 0$ inside the physical medium and $d(u) > 0$ in the PML region, a new complex coordinate $\tilde{u}$ is introduced as
  \begin{equation}\label{replace}
  \tilde{u}(u) = u + \frac{1}{j\omega}\int_0^u d(s)\mathrm{d}s.
  \end{equation}
Or equivalently,
  \begin{equation}
  \frac{\partial}{\partial \tilde{u}} = \frac{j\omega}{j\omega + d(u)}\frac{\partial}{\partial u} = s_u(j\omega)\frac{\partial}{\partial u}.
  \end{equation} 
  
\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{Fig/SpongeABC.pdf}
\caption{The damping profile $d(u)$}
\end{figure}

In the homogeneous media, the acoustic wave equation has the following solution $A \exp(-j (\bk \cdot \bx -\omega t))$, where $A$ represents the amplitude and polarization of the plane wave. The $\bk = k_x \hx + k_y \hy +k_z \hz$ denotes the wave vector, which 
indicates the direction of wave propagation of the plane wave. $\bx = x\hx +y\hy +z \hz$ is the position vector. After the replacement in (\ref{replace}), we can derive another solution of the acoustic equation as follows,
\begin{equation}
\begin{aligned}
&A\exp(-j(k_x \tilde{x} + k_y y + k_z z -\omega t))=\\
 &~~~~~~~~~~~~A\exp(-j (\bk\cdot \bx -\omega t))\exp(-kx/\omega \int_0^x d(s)ds).
\end{aligned}
\end{equation}
In the original simulated region the the new solution is equivalent to the old one, since $d_x=0$. Additionally, in the $\hat{\mathbf{n}}= \hx$ direction, the wave amplitude decay with a coefficient $\exp(-kx/\omega \int_0^x d(s)ds)$ that is inversely proportional to the angular frequency $\omega$ of the plane wave. 

In SSSI we use a non-split method, the Convolutional PML (CPML) \cite{LueHun1992, RodGed2000, KomMar2007}, which is more reasonable to work with the acoustic (pressure) source. In time domain,
  \begin{equation}
    \frac{\partial}{\partial \tilde{u}} = s_u(t) * \frac{\partial}{\partial u} = \frac{\partial}{\partial u} - \left(d(u)H(t)e^{-d(u)t}\right) * \frac{\partial}{\partial u}
  \end{equation}
The convolution can be performed as follows,
  \begin{equation}
  \left\{
  \begin{aligned}
  &\frac{\partial^2 p}{\partial t^2}=v^2(P_z+P_x)\\
  &P_z=\frac{\partial A_z}{\partial z}+\Psi_z\\
  &P_x=\frac{\partial A_x}{\partial x}+\Psi_x\\
  &A_z=\frac{\partial p}{\partial z}+\Phi_z\\
  &A_x=\frac{\partial p}{\partial x}+\Phi_x
  \end{aligned}
  \right.
  \end{equation}
  
  and  
  \begin{equation}
  \left\{
  \begin{aligned}
  &\Psi_z^{(n)}=b_z\Psi_z^{(n-1)}+(b_z-1)\partial_z^{(n-1)}A_z\\
  &\Psi_x^{(n)}=b_x\Psi_x^{(n-1)}+(b_x-1)\partial_x^{(n-1)}A_x\\
  &\Phi_z^{(n)}=b_z\Psi_z^{(n-1)}+(b_z-1)\partial_z^{(n-1)}p\\
  &\Phi_x^{(n)}=b_x\Phi_x^{(n-1)}+(b_x-1)\partial_x^{(n-1)}p\\
  &b_z = e^{-d(z)\Delta t}\\
  &b_x = e^{-d(x)\Delta t}
  \end{aligned}
  \right.
  \end{equation}

The implemention of acoustic wave propagation with CPML is \path{src/fwdTimeCpmlFor2dAw.m} and \path{src/fwdTimeCpmlFor3dAw.m}.
For higher efficiency of the simulation, the \path{fwdTimeCpmlFor2dAw.m}, which is used frequently in the seismic imaging algorithms, is also implemented with C and mex file. 

\subsection{Numerical Artifacts and Instabilities}
In seismic simulations, there are several parameters you should play with, such as the spatial grid, source function, sampling rate, etc. However, 
for the stability and accuracy of the numerical scheme, some premises should be honored when we adjust values for these parameters.  
Particularly, when Nyquist sampling criteria for the finite difference wave field simulation has not been satisfied on space or time domain, some numerical artifacts and instabilities will occur. In summary, when the spatial sampling rate is too low,  the solution suffers numerical grid dispersion; when the temporal sampling rate is too low, the Courant instability happens.

To avoid the occurrence of harmful grid dispersion the following criteria for the spatial grid spacing $\Delta u$ has to be satisfied
\begin{equation}
  \Delta u \leq \frac{\lambda_{\min}}{n} = \frac{V_{\min}}{nf_{\max}}
\end{equation}
where $n$ is the number of sampling points per wavelength, $\lambda_{\min}$ and $V_{\min}$ are the minimal wave length and velocity, and $f_{\max}$ is the maximal frequency. 
Video clips of acoustic wave propagation with and without numerical grid dispersion can be found at:
\url{https://www.youtube.com/watch?v=scBvd3FQ73U} and \url{https://www.youtube.com/watch?v=Q17tieZuhJQ}

In order to avoid the Courant instability, the time step $\Delta t$ must be less than the time for the wave to travel between two 
adjacent sampling points with grid grid spacing $\Delta u$. In the 2-D scenario,
\begin{equation}
\frac{\sqrt{2}V_{\textbf{max}}\Delta t}{\min\{\Delta z, \Delta x\}}\le \epsilon \le 1.
\end{equation}
Examples of acoustic wave propagation which are Courant stable and Courant instable can be found at
\url{https://www.youtube.com/watch?v=Gl1pNm3jF8g}  and \url{https://www.youtube.com/watch?v=wMAuhW7gzdM}. 
In the Courant instable case, noticing the color bar, the solution actually blows up over time.

One method to alleviate the numerical dispersion is flux-corrected transport (FCT) introduced by \cite{FeiLar1995}, 
which is implemented for both acoustic and elastic waves in SSSI (see \path{src/fctForAw.m} and \path{src/fctForEw.m}).
In the default simulations of acoustic and elastic waves in SSSI the application of FCT is muted, which may can slow down the 
simulation considerably. If possible, we strongly suggest to modify the sampling rate and $\Delta u$ 
to avoid the grid dispersion than employing the FCT.  


\subsection{2-D Acoustic Wave Equation in Frequency Domain}
In signal processing, a signal transformed into frequency domain may unveil hidden information in time domain and brings new processing
techniques. The acoustic wave equation given in (\ref{aw}) which is time dependent can be transformed and solved in frequency domain. 
Taking Fourier transform of (\ref{aw}) with respect to $t$ on both sides
  \begin{equation}
  \frac{\omega^2}{c^2(z, x)}P_{\omega}(z, x) + \nabla^2 P_{\omega}(z, x) =- F_{\omega}(z, x).
  \end{equation}
  We spatially discretize the simulated region as we did for the FDM in time domain.  
  Let $P_{i,j}^{(\omega)} := P_{\omega}(i\Delta z, j\Delta x)$, $F_{i,j}^{(\omega)} := 
  F_{\omega}(i\Delta z, j\Delta x)$, $c_{i,j} := c(i\Delta z, j\Delta x)$  with 1st-order finite difference approximation of the Laplace operator.
  We obtain the following discrete equation for a specific frequency $\omega$
  \begin{equation}
  \begin{aligned}
  \frac{\omega^2}{c_{i,j}^2} P_{i,j}^{(\omega)} &+\left[ \frac{P_{i-1,j}^{(\omega)} - 2P_{i,j}^{(\omega)} + P_{i+1,j}^{(\omega)}}{\Delta z^2} \right] \\&+\left[ \frac{P_{i,j-1}^{(\omega)} - 2P_{i,j}^{(\omega)} + P_{i,j+1}^{(\omega)}}{\Delta x^2} \right] =- F_{i,j}^{(\omega)}.
  \end{aligned}
  \end{equation}
  
There are some advantages of Finite Difference in Frequency Domain (FDFD) over Finite Difference in Time Domain (FDTD), we will discuss momentarily. FDFD transforms wave equation for wave fields at a constant frequency into a linear system 
\begin{equation}\label{awfreq}
\bA^{(\omega)}\bp^{(\omega)} = \bff^{(\omega)},
\end{equation}
where $\bff$ and $\bp$ are the vectorized source term $F_{i,j}$ and pressure field $P_{i,j}$.


  \begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{Fig/FDFDMatrixA.pdf}
  \caption{sparse FDFD matrix $\bA$ for a specific frequency $\omega$. Blue dots denotes the nonzero elements.}
  \label{fig:SparseA}
  \end{figure}
  In order to solve acoustic wave equation in frequency $\omega$, we only have to solve the matrix equation (\ref{awfreq}). The 
  matrix $\bA$ is highly sparse (see Figure \ref{fig:SparseA}), because $P_{i,j}$ is only dependent on its adjacent grid points and such that each row of $\bA$ has at most five nonzero entries.
  Matlab has been optimized to invert the sparse matrix. Other than the tool come along with Matlab, when the size of $\bA$ is huge, we recommend a well developed package with a Matlab interface called MUMPS (MUltifrontal Massively Parallel sparse direct Solver) to solve the sparse matrix inversion problem. 
 The concerning of data volume to store and process is another point which made FDFD excels FDTD for our application. Instead of processing the whole data set in time domain, we can solve the wave equation only in the important part of spectrum using FDFD, which considerably reduces the size of the data and makes large-scale problems (e.g., full waveform inversion) feasible. For speed purposes, since the wave equations are independent over frequencies, FDFD can be easily parallelized across frequencies.

An interesting example is the Green's function, which is the solution of wave equation with an impulse source term. Numerically,
the Green's function cannot be solved accurately with FDTD, because of the impulse function has components in arbitrarily high
frequency. This will bring serve grid dispersion to the numerical solution. However this is not a problem for FDFD. The Green's Function 
$G_{\omega}$ in frequency domain, which solves  
  \begin{equation}
  \frac{\omega^2}{c^2(z, x)}G(z, x;\omega) + \nabla^2 G(z, x;\omega) = \delta_{\omega}(z-z_0, x-x_0)
  \end{equation}
  is a the solution of (\ref{awfreq}) with the source term $\bff$ contains all one's.
  
  \begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{Fig/GreensFunction.pdf}
  \caption{Real part of the Green's function at frequency 20 Hz} 
  \end{figure}


\section{Numerical solution for elastic wave equation}
In the real media, the seismic waves are in the form of elastic waves which are composed of both P-wave and S-wave
\begin{equation}
    \left\{
    \begin{aligned}
    %v_z=\frac{\partial s_z}{\partial t}, \quad &v_x=\frac{\partial s_x}{\partial t}\\
    v_z=v_{zp}+v_{zs}, \quad &v_x=v_{xp}+v_{xs}\\
    \frac{\partial v_{zp}}{\partial t}=\alpha^2 \frac{\partial A}{\partial z}, \quad &\frac{\partial v_{xp}}{\partial t}=\alpha^2 \frac{\partial A}{\partial x}\\
    \frac{\partial v_{zs}}{\partial t}=-\beta^2 \frac{\partial B}{\partial x}, \quad &\frac{\partial v_{xs}}{\partial t}=\beta^2 \frac{\partial B}{\partial z}\\
    A=\frac{\partial s_z}{\partial z}+\frac{\partial s_x}{\partial x}, \quad &B=\frac{\partial s_x}{\partial z}-\frac{\partial s_z}{\partial x}
    %\frac{\partial A}{\partial t}=\frac{\partial v_z}{\partial z}+\frac{\partial v_x}{\partial x}, \quad& \frac{\partial B}{\partial t}=\frac{\partial v_x}{\partial z}-\frac{\partial v_z}{\partial x} 
    \end{aligned}
    \right.
    \end{equation}
  where $(v_z, v_x)$ is the particle velocity field, $v_{up}$ is P-wave field in $u$-direction $(u=x, z)$,
  $v_{us}$ is the S-wave fields in $u$-direction $(u=x, z)$, and $(s_z, s_x)$: particle displacement vector.
  We can see that in this form, we separate the P-wave and S-wave fields in the solution \cite{Che2014}. Since 
  we already split the velocity field into $z$ and $x$ directions, we use a split PML (SPML) for the FDFD. See \path{src/fwdTimeSpmlFor2dEw.m}
    
    \begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{Fig/EWCoordinates.pdf}
    \caption{Velocity separation}
    \end{figure}
    

\section{Migration}
The goal of seismic imaging is to recover the subsurface structures with the recorded seismic data. This imaging process is 
typically computationally intense. Migration is one of the most important approaches. In SSSI we implemented a few representative 
migration algorithms, such as
Kirchhoff's migration, Reverse Time Migration (RTM), Least square RTM (LSRTM).
All methods we implemented in SSSI are prestack.  

\subsection{Kirchhoff's migration}
Let $\bx_r$ be the location of the receiver and $\bx_s$ be the location of the source. 
Then $\bm=(\bx_r+\bx_s)/2$ is the midpoint, and $\bh=(\bx_r-\bx_s)/2$ is the half offset.
The involved derivation of Kirchhoff's migration (see \cite{Sch1978} for details) is omitted here. Only the simple imaging formula 
is given as below
\begin{equation}\label{KirkImaging}
I(\xi)=\int_{\Omega_\xi} W(\xi,\bm,\bh)dt(t=t_d(\xi,
\bm,\bh),\bm,\bh)d\bm d\bh,
\end{equation}
where limited region $\Omega_\xi$ is centered around the location $\xi$
in the $m$ plane, called the migration aperture. $t_d=t_s[\bx,\bs,v(z,x,y)]+t_g[\bx,\bg,v(z,x,y)]$.
For reflector $\xi = (z_\xi, x_\xi, y_\xi)$ in 3-D and $\xi = (z_\xi, x_\xi)$ in 2-D case.

  \begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{Fig/tstg.PNG}
  \caption{Reflector, and travel times (adapted from \cite{bio2006})}
  \end{figure}
  
An example of Kirchhoff's migration for the fault model (available in the \path{modelData} folder) can 
be found in \path{src/mainKirkCpmlFor2dAw_fault.m}, which is 
inherited from a existing package \cite{Koz2011}.
The most important part of Kirchhoff's migration is the computation of travel times $t_s$ and $t_g$.   
These can be done either with \path{src/ray2d.m} from \cite{Koz2011} or
\path{src/eikonal2d.m} which solves the 2-D Eikonal equation using a fast sweeping method \cite{Zha2004}.
The Eikonal equation is of the form
\begin{equation}
|\nabla T(\bx)| c(\bx)= 1, ~~\bx\in \real^2
\end{equation}
subject to $T(\bx) = 0$ for a boundary $\Gamma$. In the SSSI we consider the source point to be a single 
grid point $\bx_s$. When we solve the Eikonal equation in a truncated region, $T(\bx)$ gives the time of 
first arrival in this region. 

\subsection{Reverse Time Migration (RTM)}
The Reverse Time Migration (RTM) is a two-way wave-equation migration for accurate imaging in and below areas with complex subsurface 
structure. RTM has a relatively old origin, however it has not been used routinely until recently because of its
computation expense. In RTM a forward wave propagation and a reverse time wave propagation need to be 
simulated, which requires a lot of computation power. However, RTM has a number of advantages over conventional depth migration methods such as 
handing evanescent energy and no dip limitation \cite{Mcm1983, BayKosAO1983}. In summary, RTM is implemented in three steps. 
\begin{enumerate}
\item record forward wave field $p_f(\bx, t; \bx_s)$ through the true velocity model
\item solve the reverse wave field $p_r(\bx, t)$ by the received surface data through the incident model, which is typically a smoothed version of the true model
\item superposition of above using an imaging condition (chosen from a number existing imaging conditions)
\end{enumerate}
The second step is equivalent to reverse the recorded traces in time. Then input those traces as source function and solve the wave field. 

For instance, an imaging condition with cross-correlation is 
\begin{equation}\label{RTMImaging}
I(\bx) = \sum_{\bx_s} \frac{\int_0^T p_f(\bx, t; \bx_s)p_r(\bx, t)\mathrm{d}t}{\int_0^T |p_f(\bx, t; \bx_s)|^2\mathrm{d}t + \epsilon^2}.
\end{equation}
Worth noticing that, using the imaging conditions (\ref{KirkImaging}), (\ref{RTMImaging}), and many other imaging conditions, the values $I(\bx)$ are not necessarily to be in the model domain. It only depicts the locations of the reflectors. Based on a migrated image, we may only qualitatively claim that the stronger model perturbation gives greater values in the image. 


\begin{figure}
\centering
\includegraphics[width=1\textwidth]{Fig/MarmousiRTM.pdf}
\caption{RTM results. (a) Marmousi model, (b) accumulated RTM result; (c) a sample shot record; (d) migrated result of the sample shot. The parameters settings are 15 Hz (center frequency) Ricker wavelet, 384 sensors, 384 shots, grid size $122 \times 384$, $\Delta z = \Delta x = 24m$.}
\label{fig:RTM}
\end{figure}

The RTM result of Marmousi model is illustrated with Figure \ref{fig:RTM}. In order to show the aggregating process across source shots, another result for faults model can be viewed in this video clip
\url{https://www.youtube.com/watch?v=lL-UpW-5xms&feature=youtu.be}.



\section{Least Square Reverse Time Migration (LS-RTM)}
RTM serves the imaging complex structures purposes as a reliable method. However, there are still some distortions caused by RTM crosstalk
artifacts. Mathematically, the migration operator is just a adjoint of the forward modeling operator, it does not minimize the mismatch of the observed and simulated traces. Least Square RTM (LSRTM) introduced by \cite{NemWuAO1999} derives an imaging condition by formulating migration as an inverse problem based on a least-squares misfit function. The implementation of LSRTM can either be time domain or frequency domain.

The model $m(\bx)=1/c^2(\bx)$ denotes the square slowness at point $\bx$. 
We consider the decomposition of model $m$ into a smooth model (initial guess) and a rough perturbation:
\begin{equation}
m(\bx)=m_0(\bx)+\delta m(\bx),
\end{equation} 
where $m_0$ is the smooth model and $\delta m(\bx) \ll m_0(\bx)$. We split the wave field $p(\bx,t)$ into 
\begin{equation}
p=p_0+\delta p,
\end{equation}
where $p_0$ solves the wave equation in the incident model $m_0(\bx)$.
In light of the advantages we have mentioned above, we formulate the problem in frequency domain (For the LSRTM in time domain, one can use the iterative method in \cite{DonCaiAO2012}).
Accordingly, $P(\bx_s,\bx;\omega)$, the waveform generated by source at position $\bx_s$, can also be split into two parts: the incident wavefield $P_0$
and $\delta P$. The $P_0(\bx_s,\bx;\omega)$ is determined by the smooth model and source function via the following acoustic wave equation:
\begin{equation}
\cL( m_0) P_0(\bx_s,\bx; \omega)=F_s(\omega),
\end{equation} 
where operator $\cL( m_0)=\Big(-\omega^2 m_0(\bx)-\Delta\Big)$ and the $F_s(\omega)$ gives the source function at source location $\bx_s$. 
Using Born approximation, the scattered filed can be approximated by  
\begin{equation}
\cL( m_0)\delta P(\bx_s,\bx;\omega) =\omega^2 \delta m P_0(\bx_s,\bx;\omega).
\end{equation}
Denote $G(\bx_s,\bx; \omega)$ as the Green's functions from the shot position $\bx_s$ to a point in the model space $\bx$, which is the solution of 
\begin{equation}
\cL(m_0)G(\bx_s,\bx;\omega)=\delta(\bx-\bx_s).
\end{equation}
It is worth noting that the Green's function $G$ is only dependent on the smooth model 
$m_0$. In least square migration, with an accurate smooth model, i.e. starting model, we can calculate the Green's function and save it for the use of every iteration without updating. 
  
Then the incident field $u_0$ at the surface point $\bx$ becomes
\begin{equation}
P_0(\bx_s,\bx; \omega)=F_s(\omega)G(\bx_s,\bx; \omega).
\end{equation}
And the secondary filed as the surface point $\by$ can be written as 
\begin{equation}
\delta P(\bx_s,\by; \omega)=\omega^2 \sum_{\bx}  \delta m(\bx) P_0(\bx_s,\bx;\omega) G(\bx,\by;\omega).
\end{equation}



For $\by=\bx_r$, we obtain the Born approximation of the synthetic field at the receiver position $\bx_r$. In general, the synthetic data for one frequency $\omega$, a shot positioned at $\bx_s$, and a receiver positioned at $\bx_r$ can be given by a linear operator $L(\bx_s,\bx_r)$ acting on the model $m(\bx)$, as follows:
\begin{align}
\delta P(\bx_r,\bx_s;\omega)&=L(\bx_s,\bx_r)\delta \bm=\omega^2 F_s(\omega)\sum_{\bx}\delta m(\bx)G(\bx_s,\bx;\omega)G(\bx,\bx_r;\omega)\nonumber\\
&=\omega^2 [...,F_s(\omega)G(\bx_s,\bx;\omega)G(\bx,\bx_r;\omega),...]\delta \bm
\end{align} 
We can write the forward model operator as a $n_s n_r\times K$ matrix $\bL$
\begin{equation}\label{Loperator}
\bL(\bx_s,\bx_r;\omega) = \omega^2 [...,L(\bx_s,\bx_r)^*,...]^*.
\end{equation}




  \begin{equation}
  \begin{aligned}
  %\hspace{-20pt}
  J&(\delta \bm) = \frac{1}{2} \sum\limits_{\omega,\bx_s,\bx_r}  \left| P^{\text{(sim)}}(\bx_r, \bx_s; \omega) - P^{\text{(obs)}}(\bx_r, \bx_s; \omega) \right|^2 \\
  &= \frac{1}{2} \sum\limits_{\omega,\bx_s,\bx_r} \Big| \omega^2 F_s(\omega) \sum\limits_{\bx}\delta m(\bx)G_{\omega}(\bx; \bx_s)G_{\omega}(\bx_r; \bx) \\&- \delta P^{(obs)}(\bx_r, \bx_s; \omega) \Big|^2\\
  &= \frac{1}{2} \left\| \bL\delta \bm - \delta\bP^{(obs)}\right\|_2^2,
  \end{aligned}
  \end{equation}
  where $\delta m$ is the module perturbation (roughly saying, the reflectors), $\bL$ is the forward modeling operator. The superscript (sim) means simulated results and (obs) means
  observed. The optimized model perturbation is 
    \begin{equation}
    \delta \bm^{\text{(opt)}} = \left( \bL^{*}\bL \right)^{-1} \bL^{*} \delta\bP^{(obs)}.
    \end{equation}
    Apparently, LSRTM is the simply a preconditioned RTM migration result $\bL^{*}\delta \bP^{(obs)}_{\omega}$. 
    Instead of solving the huge inverse matrix $(\bL^{*}\bL)^{-1}$,  we use the Gauss-Newton method with a diagonal approximation 
    of the Hessian matrix. In the case of large acquisition aperture, wide frequency band and slow variation of the velocity model, the Hessian matrix
    is diagonal. In a simulation such as Marmousi model, the Hessian matrix is diagonal dominated. 

The gradient is 
\begin{equation}
\bg_k(\delta\bm)=\text{Re}\bigg(\sum_{\omega,\bx_s,\bx_r } \omega^2  \bar{F}_s(\omega) \bar{G}_\omega(\bx_s,\bx)\bar{ G}_\omega(\bx,\bx_r)\Delta d(\bx_s,\bx_r;\omega)\bigg), 
\end{equation}
where $\Delta d(\bx_s,\bx_r;\omega)=\bL\delta \bm - \delta\bP^{(obs)}$. 

As discussed in the preceding sections, the Hessian matrix can be approximated by its diagonal elements.
\begin{equation}
\bH(\bm)= \text{Re}\bigg( \sum_{\omega,\bx_s,\bx_r} \omega^4 |F_s(\omega)|^2 |G(\bx_s,\bx;\omega)|^2 |G(\bx,\bx_r;\omega)|^2 \bigg)
\end{equation} 

\begin{equation}
\delta \bm^{k+1}=\delta \bm^{k} - \bH^{-1} \bg_k(\delta \bm^k),
\end{equation}
where the initial value $\delta \bm^0$ can be obtained using RTM $\bL^* \delta \bP$ with an imaging condition that maps into the model domain.
In the LSRTM, since we do not update the incident model $\bm_0$, the Green's functions and Hessian only need to be computed once and stored
for use in the later iteration. 


\section{Full Waveform Inversion (FWI) in frequency domain}
The migration operator should have a incident model (usually a smoothed version of the true model) as an input. In complex media, building an accurate smooth model is challenging. In contrast, the starting model of FWI (see \cite{VirOpe2009} as an overview) can be very rough, since in each iteration the updated model will be new starting point for the following iteration. However, the Green's function should also be updated in order to converge fast. In the frequency domain, the formulation is similar to the LSRTM. The only thing different is we will update the incident model as well as the Green's functions over iterations. Applying the same approach, the cost function $J(\delta \bm)$ can be optimized by more approaches: conjugate-gradient, quasi-Newton, etc.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\WHILE{$m(\bx)$ is not converged}
\STATE Generate Green's functions at each shot and receiver
\STATE Generate scattering wave field $\delta\bP^{(obs)}_{\omega}= \bP_{\omega}^{\text{(obs)}} - \bG_{\omega}(m)\bF_{\omega}$ for all $\omega$
\STATE $\delta \bm^{\text{(opt)}} = \arg\min J(\delta \bm) = \arg\min \frac{1}{2} \left\| \bL(\bm)\delta \bm - \delta\bP^{(obs)}\right\|_2^2$
\STATE $\bm \leftarrow \bm + \delta \bm$
\ENDWHILE
\end{algorithmic}
\caption{Full Waveform Inversion}
\end{algorithm}


\section*{Acknowledgement}
\addcontentsline{toc}{section}{Acknowledgement}
Some of SSSI source files are inherited from other open source package. We are grateful for those contributions. 
Please read the comments in codes for authorship and contact information. Particularly, we
want to thank Stuart Kozola, the author of the package of Large Data in MATLAB: A Seismic Data Processing Case Study, 
his excellent work motivates us to develop SSSI.  We have tried very hard to find 
However, some source files are lack of authorship.

\bibliographystyle{ieeetr}
\bibliography{UserGuide}






\end{document}
